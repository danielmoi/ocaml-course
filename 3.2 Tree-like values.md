# Tree-like values

We will go further with recursive datatypes.

Tree-like datastructures are also omnipresent in CS because they allow
for a hierarchical organization of data.

Defining a type for a tree is straightforward in OCaml using a
recursive algebraic datatype.

We will refactor our typed database by replacing arrays with such
a tree-like representation.

------------------------------------------------------------
## A tree-like representation for databases

Consider the following tree-like representation for databases:
```ocaml
type database =
| NoContact
| DataNode of database * contact * database
```

Here there is a left-child database, and a right-child database

We will enforce a VARIANT.

A database node DataNode (left, c, right) is well-formed if
- every contact in left is lexicographically smaller than c
- every contact in right is lexicographically greater than c

- lexicographically = dictionary

------------------------------------------------------------
## In the machine
Root DataNode db    luke      db
              |                |
              |                DataNode
              DataNode

------------------------------------------------------------
## Looking for a contact
```ocaml
let search db name =
  let rec traverse = function
  | NoContact -> Error
  | DataNode (left, contact, right) ->
    if contact.name = name then
      FoundContact contact
    else if name < contact.name then
      traverse left
    else traverse right
  in traverse db
;;
```

------------------------------------------------------------
## A more efficient lookup
- in the worst case, the contact is not found, and we have crossed a number of
  nodes which is bounded by the height of tree
- in the array-based implementation, the entire database is traversed
- it is unlikely that the height of the tree is equal to the number of contacts!
  (this would mean that the tree is degenerated into a list)
- as an exercise, try to maintain the extra invariant that the tree is BALANCED,
  ie. that its height is bounded by the logarithm of the number of contacts

------------------------------------------------------------
## Inserting a contact
```ocaml
let insert db contact =
  let rec traverse tree =
    match tree with
    | NoContact ->
      (* return a new, empty, database *)
        DataNode (NoContact, contact, NoContact)
    | DataNode (left, contact', right) ->
      if contact.name = contact'.name then tree
      else if contact.anme < contact'.name then
        (* we keep / re-use the same "right" *)
        DataNode (traverse left, contact', right)
      else
        (* we keep / re-use the same "left" *)
        DataNode (left, contact', traverse right)
  in
  NewDatabase (traverse db)
  ;;

ie. insertion shares subtrees between databases

ie. insertion is sharing original subtrees from the input database

```

------------------------------------------------------------
## Removing an element
Removing the root, would leave us with 2 subtrees.

```
            1
          /   \
        2       5
       / \     / \
      3   4   6   7

        2       5
       / \     / \
      3   4   6   7
```

Removing an element seems a bit complicated.
We should be able to focus on the tree problem, independently
  of the fact that it represents a database.

This is the separation of concerns princple.

Forthcoming PARAMETERIZED TYPES will help us perform such a
MODULAR DEVELOPMENT.