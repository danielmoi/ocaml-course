# Recursive Types

LIST is a ubiquitous data structure in FP.

The TYPE for a list is a recursive algebraic datatype.

------------------------------------------------------------
In Computer Science, many data structures like lists or trees have an UNBOUND
DEPTH.

For the moment, we are unable to define a type for such data structures because
we only have seen "flat" data types...

Informally, a list of integers is either:
- an empty list
- an integer, and the REST of the list

We already know how to define a type by cases using SUM TYPES, which is what
that looks like.

What we have to realize is that the REST of the list, is ALSO a LIST...

So we just have to reuse the name of the type inside of the type definition!

------------------------------------------------------------
```ocaml
type int_list =
  | EmptyList
  | SomeElement of int * int_list;;
                        ^ we are re-using the name, so this is a recursive type
```

Where
- int_list is a SUM TYPE
- EmptyList and SomeElement are TAG IDENTIFIERs
  - when we use a tag identifier to construct a value, it is called a CONSTRUCTOR
  - and int * int_list is an expression


------------------------------------------------------------
## In the machine
The following value,
```ocaml
SomeElement (1, SomeElement (3, EmptyList))
```

That implements a LINKED LIST data structure.

SomeElement 1 [ x ]
                |
                |---------------> SomeElement 3 EmptyList


Where x is a POINTER to another list.

------------------------------------------------------------
## Recursive Types
A SUM TYPED can refer to itsself in its own definition

Such a sum type is therefore recursive

Functions over a recursive type are often defined by CASE ANALYSIS and RECURSION

------------------------------------------------------------
## Recursive types
```ocaml
type int_list =
  | EmptyList
  | SomeElement of int * int_list;;

let rec length l =
  match l with
  | EmptyList -> 0
  | SomeElement (x, l) -> 1 + length l;;
- val length : int_list -> int = <fun>

Same as:
let rec length = function
  | EmptyList -> 0
  | SomeElement (element, sublist) -> 1 + length sublist;;
- val length : int_list -> int = <fun>

```

------------------------------------------------------------
## A Predefined type for Lists

Lists are so important in FP, that there is a type for lists.

The type for lists of elements of type t is defined as: t list

The empty list is written: []

[] is a special TAG.

It corresponds to EmptyList in the previous example.

An integer "i" followed by the rest of the list "r" is written: i :: r

:: is a special TAG, corresponding to SomeElement

A list can be defined by enumeration:
```
[ some_expression; ... ; some_expression ];;
```

------------------------------------------------------------
## Length of list, using the predefined tags
```ocaml
let rec length = function
  | [] -> 0
  | x :: xs -> 1 + length xs;;
- val length : 'a list -> int = <fun>
- NOTE: this list is now a GENERIC list

let three = length [1; 2; 3; ];;
```
------------------------------------------------------------
## Reverse a list
```ocaml
let rec reverse = function
  | [] -> []
  | x :: xs -> reverse xs @ [ x ];;

  - we are CONCATENATING the HEAD of the original list to the REST of the original list
  - we get a function "from list" "to list"

let l = reverse [1; 2; 3; ];;
```



Note that we are concatenating 2 lists, and the cost of this is linear in the
size of the first list. So what we get in the end is a QUADRATIC EQUATION (?!!!)


That is a costly function, so let's refactor

This is called "ACCUMULATION PASSING STYLE" in FP...

The idea is that we add an extra argument "accu" that will contain the final
result of the computation.



```ocaml
let rec reverse_aux accu = function
  | [] -> accu
  - ie. when we have finished traversing the list (we have an empty list)

  | x :: xs -> reverse_aux (x :: accu) xs;;
  - when we have a non-enpty list, with "x" as the HEAD,
  - we push that element "x" to the top of the list "accu" and we do a
    recursive call to the rest of the list...

  - this has the advantage of being linear in the size of the list.
  - because we traverse the INPUT LIST ("x"), and at each step, we only
    do a CONSTANT TIME OPERATION ("::"), where we construct a list with "::"
    with "x" and the "accu"

let reverse l = reverse_aux [] l;;

let l = reverse [1; 2; 3;];;
```

------------------------------------------------------------
You don't only have to have 2 cases when you define a function
by recursion of a list:

```ocaml
let rec uniq = function
  | [] -> []
  | [x] -> [x]
  | x :: x' :: xs ->
    if x = x' then
      uniq (x' :: xs)
    else
      x :: uniq (x' :: xs);;

let l1 = uniq [1;2;2;3;4;3];;
- val l1 : int list = [1; 2; 3; 4; 3]



```
------------------------------------------------------------
## The @ operator
The "@" operator is an infix operator.
It is the same as Array.append
```ocaml
# [] @ [];;
- : 'a list = []

# [1] @ [2];;
- : int list = [1; 2]
```
------------------------------------------------------------
## The :: operator
```
# [] :: [];;
- : 'a list list = [[]]

# [1]::[1];;
Error: This expression has type int but an expression was expected of type
         int list

# 1 :: [1];;
- : int list = [1; 1]

```