# Recursive Types

LIST is a ubiquitous data structure in FP.

The TYPE for a list is a recursive algebraic datatype.

------------------------------------------------------------
In Computer Science, many data structures like lists or trees have an UNBOUND
DEPTH.

For the moment, we are unable to define a type for such data structures because
we only have seen "flat" data types...

Informally, a list of integers is either:
- an empty list
- an integer, and the REST of the list

We already know how to define a type by cases using SUM TYPES, which is what
that looks like.

What we have to realize is that the REST of the list, is ALSO a LIST...

So we just have to reuse the name of the type inside of the type definition!

------------------------------------------------------------
```ocaml
type int_list =
  | EmptyList
  | SomeElement of int * int_list;;
                        ^ we are re-using the name, so this is a recursive type
```

Where
- int_list is a SUM TYPE
- EmptyList and SomeElement are TAG IDENTIFIERs
  - when we use a tag identifier to construct a value, it is called a CONSTRUCTOR
  - and int * int_list is an expression


------------------------------------------------------------
## In the machine
The following value,
```ocaml
SomeElement (1, SomeElement (3, EmptyList))
```

That implements a LINKED LIST data structure.

SomeElement 1 [ x ]
                |
                |---------------> SomeElement 3 EmptyList


Where x is a POINTER to another list.

------------------------------------------------------------
## Recursive Types
A SUM TYPED can refer to itsself in its own definition

Such a sum type is therefore recursive

Functions over a recursive type are often defined by CASE ANALYSIS and RECURSION

------------------------------------------------------------
## Recursive types
```ocaml
type int_list =
  | EmptyList
  | SomeElement of int * int_list;;

let rec length l =
  match l with
  | EmptyList -> 0
  | SomeElement (x, l) -> 1 + length l;;
- val length : int_list -> int = <fun>

Same as:
let rec length = function
  | EmptyList -> 0
  | SomeElement (element, sublist) -> 1 + length sublist;;
- val length : int_list -> int = <fun>

```

------------------------------------------------------------
## A Predefined type for Lists

Lists are so important in FP, that there is a type for lists.

The type for lists of elements of type t is defined as: t list

The empty list is written: []

[] is a special TAG.

It corresponds to EmptyList in the previous example.

An integer "i" followed by the rest of the list "r" is written: i :: r

:: is a special TAG, corresponding to SomeElement

A list can be defined by enumeration:
```
[ some_expression; ... ; some_expression ];;
```

------------------------------------------------------------
## Length of list, using the predefined tags
```ocaml
let rec length = function
  | [] -> 0
  | x :: xs -> 1 + length xs;;
- val length : 'a list -> int = <fun>
- NOTE: this list is now a GENERIC list

let three = length [1; 2; 3; ];;
```
------------------------------------------------------------
## Reverse a list
```ocaml
let rec reverse = function
  | [] -> []
  | x :: xs -> reverse xs @ [ x ];;

  - we are CONCATENATING the HEAD of the original list to the REST of the original list
  - we get a function "from list" "to list"

let l = reverse [1; 2; 3; ];;
```



Note that we are concatenating 2 lists, and the cost of this is linear in the
size of the first list. So what we get in the end is a QUADRATIC EQUATION (?!!!)


That is a costly function, so let's refactor

This is called "ACCUMULATION PASSING STYLE" in FP...

The idea is that we add an extra argument "accu" that will contain the final
result of the computation.



```ocaml
let rec reverse_aux accu = function
  | [] -> accu
  - ie. when we have finished traversing the list (we have an empty list)

  | x :: xs -> reverse_aux (x :: accu) xs;;
  - when we have a non-enpty list, with "x" as the HEAD,
  - we push that element "x" to the top of the list "accu" and we do a
    recursive call to the rest of the list...

  - this has the advantage of being linear in the size of the list.
  - because we traverse the INPUT LIST ("x"), and at each step, we only
    do a CONSTANT TIME OPERATION ("::"), where we construct a list with "::"
    with "x" and the "accu"

let reverse l = reverse_aux [] l;;

let l = reverse [1; 2; 3;];;
```

------------------------------------------------------------
You don't only have to have 2 cases when you define a function
by recursion of a list:

```ocaml
let rec uniq = function
  | [] -> []
  | [x] -> [x]
  | x :: x' :: xs ->
    if x = x' then
      uniq (x' :: xs)
    else
      x :: uniq (x' :: xs);;

let l1 = uniq [1;2;2;3;4;3];;
- val l1 : int list = [1; 2; 3; 4; 3]



```
------------------------------------------------------------
## The @ operator
The "@" operator is an infix operator.
It is the same as Array.append
```ocaml
# [] @ [];;
- : 'a list = []

# [1] @ [2];;
- : int list = [1; 2]
```
------------------------------------------------------------
## The :: operator
```
# [] :: [];;
- : 'a list list = [[]]

# [1]::[1];;
Error: This expression has type int but an expression was expected of type
         int list

# 1 :: [1];;
- : int list = [1; 1]

```

------------------------------------------------------------
## Quiz: First in, First Out
Queues are a standard FIFO structure.

In this exercise, we implement a queue with a pair of two lists (front, back)
such that front @ List.rev back represents the sequence of elements in the
queue.

Write a function is_empty : queue -> bool such that is_empty q is true if and only if q has no element.
```ocaml
let is_empty = function
  | [] -> true
  | [x] -> false;;
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_
val is_empty : 'a list -> bool = <fun>


let is_empty = function
  | [] -> true
  | _ -> false;;
Wrong type 'a list -> bool.

We need queue -> bool

type queue = int list * int list;;

let is_empty (front, back) =
  if List.length back = 0 then true
  else false;;


NB. Straight of the bat, we use LIST:
# let x = [1;2;3;4];;
val x : int list = [1; 2; 3; 4]

```
Solution:
```ocaml
let is_empty (front, back) =
  if (List.length back = 0 || List.length front = 0) then true
  else false;;
```

------------------------------------------------------------
Write a function enqueue : int -> queue -> queue
such that enqueue x q is the queue as q except that x is at the end of the queue.

```ocaml
type queue = int list * int list;;
type enqueue = int -> queue -> queue;;

let enqueue int queue =
  queue @ [int];;

let enqueue x (front, back) =
  front::back @ [x];;

# enqueue 34 (0, [1;2;3]);;
- : int list = [0; 1; 2; 3; 34]

- Wrong type 'a -> 'a * 'a list -> 'a list.

let enqueue x (front, back) =
  front::back :: x;;
Wrong type 'a list -> 'a * 'a -> 'a list.

let enqueue x (front, back) = (front::back) @ x;;

let enqueue x (front, back) = (front, back) @ x;;

let enqueue x (head, tail) =
  let existing = head :: tail in
  existing :: x;;

let enqueue x (head, tail) = (head :: tail, x);;
Wrong type 'a -> 'b * 'b list -> 'b list * 'a.

let enqueue x (head, tail) = (head, tail::x);;

let enqueue x (front, back) = (front :: List.hd back, List.tl :: x);;

  # ([1], [2]);;
- : int list * int list = ([1], [2])

let enqueue x q = q :: x;;

In this exercise, we implement a queue with a pair of two lists (front, back) such that front @ List.rev back represents the sequence of elements in the queue.

This is a queue of a PAIR of two LISTS
[1;2;3], [3;2;1]
int list * int list

type queue = int list * int list

let enqueue x (front_list, back_list) = (front_list :: x, x :: back_list);;

# let enqueue x (front_list, back_list) = (front_list :: x, x :: back_list);;
val enqueue : 'a list -> 'a * 'a list list -> 'a list * 'a list list = <fun>

# let enqueue x (front_list, back_list) = (front_list @ x, x @ back_list);;
val enqueue : 'a list -> 'a list * 'a list -> 'a list * 'a list = <fun>

# let enqueue (x: int) (front_list, back_list) = (front_list :: [x], [x] @ back_list);;
val enqueue : int -> int * int list -> int list * int list = <fun>

# let enqueue (x: int) (front_list, back_list) = (front_list @ [x], [x] @ back_list);;
val enqueue : int -> int list * int list -> int list * int list = <fun>

THIS IS NOW THE RIGHT TYPE:
# let enqueue x (front_list, back_list) = (front_list @ [x], [x] @ back_list);;
val enqueue : 'a -> 'a list * 'a list -> 'a list * 'a list = <fun>


enqueue -4 ([3; -1; 4; -4; -1; 3; -4], [3; 3; 3; -2; -3])

let enqueue (x: int) (first, second) = (first, second @ [(x)]);;
let enqueue x (first, second) = (first, second @ [(x)]);;

let enqueue (x: int) (first, second) = (first, x @ List.rev second );;
let enqueue (x: int) (first, second) = (first, x :: List.rev second );;
let enqueue (x: int) (first, second) = (first, List.rev second @ [x]);;
let enqueue (x: int) (first, second) = (first, [x] @ List.rev second );;


OMG THIS IS IT.
let enqueue (x: int) (first, second) = (first, x :: second  );;
- we are simply using "x" as the head, and sticking "second" onto it...

```

------------------------------------------------------------
Write a function `split : int list -> int list * int list`

such that
`split l = (front, back)` where `l = back @ List.rev front`

and the length of `back` and `front`
is `List.length l / 2` or `List.length l / 2 + 1`

```ocaml
let split (l: int list) =


let rec take n list =
  match list with
  | [] -> []
  | x :: rest ->
    if x = n then [x]
    else list;;

let rec take n list =
  match list with
  | [] -> []
  | [x] -> [x]
  | head :: rest  ->
    let reversed = List.rev rest in
    let [last :: rest] = reversed in
    List.rev rest
  ;;

let rec take n list =
  match list with
  | [] -> []
  | [x] -> [x]
  | head :: rest  ->
    let reversed = List.rev rest in
    let [last :: rest] = reversed in
    List.rev rest
  ;;

take 2 [1;2;3];;