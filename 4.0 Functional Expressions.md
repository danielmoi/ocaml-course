# Functional Expressions

Expressions can denote functional values.
These correspond to the so-called LAMBDA-EXPRESSIONS
that also exist in other languages like Python and Java.


Syntax:
```ocaml
function id -> exp
```

Function taking 1 argument `id`, and returning the value
of expression `exp`.
This function has NO NAME.
It's body is written in the expression `exp`

Example:
```
function x -> x + 1;;
```

Scope of `id` is restricted to `exp`

Type t1 -> t2 where
- t1 is the type of id
- t2 is the type of expression

------------------------------------------------------------
## Example
```
function x -> x + 1;;

function y -> [ [y + 2, y+3]; [y; y*y]];;
- int -> List of Lists
- int -> int list list

(function x -> 2 *x) 5;;
- this is function application
- it evaluates to 10

```

------------------------------------------------------------
## Defining Functions
The previous way of defining functions
```ocaml
let f x = e
```

That is just an ABBREVIATION for
```ocaml
let f = function x -> e
```

- this is just a DEFINITION for the IDENTIFIER "f"
- we are BINDING the identifier "f" to the value of the expression,
which is a FUNCTION, ie. a FUNCTION EXPRESSION
- expression = anything that evaluates to a value.
- So, there is just ONE uniform way of DEFINING IDENTIFIERS: "let"


------------------------------------------------------------
## Example
```ocaml
let double x = 2 * x;;

double 3;;

let double = function x -> 2 * x;;

let double = (function x -> 2 * x);;

double 3;;
```

------------------------------------------------------------
## Functions with Pattern Matching
The GENERAL form of a function definition is:
(a sequence of patterns)
```
function
| pattern_1 -> expression_1
| ...
| pattern_n -> expression_n
```

So, the form `function x -> exp` is just ONE special case of that
general form!

------------------------------------------------------------
## Example
```ocaml
let rec length = function
| [] -> 0
| _::r -> 1 + length r;;

length [17; 42; 73];;

type expr =
| Int of int
| Add of expr * expr
;;

let rec eval = function
| Int n -> n
| Add (e1, e2) -> (eval e1) + (eval e2)
;;

eval (Add (Add (Int 2, Int 5), Int 7));;


```