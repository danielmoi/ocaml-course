# Functions As First-Class Values

Expressions may denote integers, boolean, .... or FUNCTIONS

In functional languages, functions are just values of a particular type

This allows us to use ONE uniform way of naming a value: `let y = ...`

Types govern function application.
We can apply e1 to e2 when
- e1 has a type t1 -> t2
  - ie. a functional type
- t1 matches the type of e2

This doesn't stop here: functions may, as any other values,
- be part of a structured data value, like a list / record / etc
- be actual arguments of functions
- be the result value of a function application

This is what it means for a function to be a "First-Class Value"

------------------------------------------------------------
## Example
```ocaml
let fl = [(function x -> x + 1); (function x -> 2 * x)];;
- a list of functions => "fl"
- val fl: (int -> int) list = [<fun>; <fun>];;

(List.hd fl) 17;;
```

------------------------------------------------------------
## Example
```ocaml
- this function takes a function as its first argument
let apply_twice f x = f (f x);;

apply_twice (function x -> 2 * x) 1;;
- this is a polymorphic type, because there is nothing that enforces constraints

let rec apply_n_times f n x =
if n <= 0 then x
else apply_n_times f (n-1) (f x);;

apply_n_times (function x -> 2 * x) 10 1;;
- 1024
```

------------------------------------------------------------
## Example

```ocaml
let compose f g = (function x -> f(g x));;
- val compose: ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
- the return type of "compose" is the return type of "f"
```

This RETURNS a FUNCTION
- f is applied to g
- g is applied to x

```
(compose (function x -> x + 1) (function x -> 2 * x)) 10;;

(compose (function x -> x + 1) (function x -> x *. 3.14)) 10;;
- this is a type error
- because the first function has type int, but the second function has type float
```

------------------------------------------------------------
## Function pitfalls
Functions apply in order from LEFT to RIGHT:
`exp1 exp2 exp3`
is equivalent to:
`(exp1 exp2) exp3`

We say "function application associates to the LEFT"

------------------------------------------------------------
## Example
```ocaml
let double = function x -> 2 * x;;

double double 5;;
- Type Error
- "double" is expecting 1 argument, an int, and we have given 2, one of which is function (itself)


double (double 5);;
- 20
- we use parentheses to override / dictate the left associativity
```